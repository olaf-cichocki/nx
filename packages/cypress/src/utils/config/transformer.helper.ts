// TODO(caleb): this feels wrong? but unsure how else to use cypress types
//  without causing issues in testing types from jest
/// <reference types="cypress" />
import {Node, SyntaxKind} from 'typescript';

export type CypressConfig = Cypress.ConfigOptions;
type CypressComponentProperties = keyof CypressConfig['component'];
type CypressE2EProperties = keyof CypressConfig['e2e'];
type CypressTopLevelProperties = Exclude<keyof CypressConfig,
  'component' | 'e2e'>;

export type CypressConfigPropertyPath =
  | `component.${CypressComponentProperties}`
  | `e2e.${CypressE2EProperties}`
  | CypressTopLevelProperties;

export function isBooleanLiteral(node: Node) {
  return (
    node.kind === SyntaxKind.TrueKeyword ||
    node.kind === SyntaxKind.FalseKeyword
  );
}

/**
 * Intersection
 * @desc From `T` pick properties that exist in `U`
 * @example
 *   type Props = { name: string; age: number; visible: boolean };
 *   type DefaultProps = { age: number };
 *
 *   // Expect: { age: number; }
 *   type DuplicateProps = Intersection<Props, DefaultProps>;
 */
export type Intersection<T extends object, U extends object> = Pick<T,
  Extract<keyof T, keyof U> & Extract<keyof U, keyof T>>;

/**
 * SetDifference (same as Exclude)
 * @desc Set difference of given union types `A` and `B`
 * @example
 *   // Expect: "1"
 *   SetDifference<'1' | '2' | '3', '2' | '3' | '4'>;
 *
 *   // Expect: string | number
 *   SetDifference<string | number | (() => void), Function>;
 */
export type SetDifference<A, B> = A extends B ? never : A;

/**
 * Diff
 * @desc From `T` remove properties that exist in `U`
 * @example
 *   type Props = { name: string; age: number; visible: boolean };
 *   type DefaultProps = { age: number };
 *
 *   // Expect: { name: string; visible: boolean; }
 *   type DiffProps = Diff<Props, DefaultProps>;
 */
export type Diff<T extends object, U extends object> = Pick<T,
  SetDifference<keyof T, keyof U>>;

/**
 * Overwrite
 * @desc From `U` overwrite properties to `T`
 * @example
 *   type Props = { name: string; age: number; visible: boolean };
 *   type NewProps = { age: string; other: string };
 *
 *   // Expect: { name: string; age: string; visible: boolean; }
 *   type ReplacedProps = Overwrite<Props, NewProps>;
 */
export type Overwrite<T extends object,
  U extends object,
  I = Diff<T, U> & Intersection<U, T>> = Pick<I, keyof I>;
